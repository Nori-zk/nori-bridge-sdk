# Preamble

Problems with o1js not always compiling ZK programs such that they yield a verification key hash with the same value in all compliation situations. Particularly concerning one ZK program namely EthVerifier (located here `<nori-bridge-sdk root directory>/o1js-zk-utils/src/ethVerifier.ts`)

# Description

We have had constant problems with the reliability of building zk programs with consistent vks for some of our programs and we have a historically relied on a defensive solution for to assist us in mitigating such behaviour, developed in March 2025. We 'bake' verification key hash strings into the repository itself for EthVerifier they can be seen here `<nori-bridge-sdk root directory>/o1js-zk-utils/src/integrity/EthVerifier.VkHash.json` which is generated when running `cd <nori-bridge-sdk root directory>/o1js-zk-utils && npm run bake-vk-hashes` which creates an cache emphemeral directory and compiles EthVerifier in this fresh directory and then stores the VK's hash into the json file. Later when running programs which rely on this zk program, we compile using the default o1js cache dir and then compare the compiled vk hash against the stored hash, if the vk hash does not match we throw an exception (and we advice the user to clear their o1js cache), this panic prevents other spurious error down the line which can have confusing descriptions. Thus the aim is to  validate our compile zk program and ensure that the zk program is reliably reproduced from the default cache directory when running in node.js (typically found at `~/.cache/o1js` on ubuntu) or from within browser (which effectively always has a cold cache for zk programs [not nessesarily for contracts which may have a bespoke cache strategy]).

When running `cd <nori-bridge-sdk root directory>/o1js-zk-utils && npm run bake-vk-hashes` or one of the a test e.g. one located in `cd <nori-bridge-sdk-root-dir>/contracts/mina/token-bridge` running `rm ~/.cache/o1js/* && npm run test -- src/micro/e2e.litenet.without-infra.spec.ts` or `rm ~/.cache/o1js/* && npm run test -- src/micro/e2e.devnet.without-infra.spec.ts`, we obtain the following vk hash for EthVerifier `18898419980749081858185627310467310990096965437609867313373155526674043887824` (referred to as 'ending in 24').

Moreover it is important to note we have another smart contract which depends on EthVerifier namely EthProcessor (located in `<nori-bridge-sdk root directory>/contracts/mina/eth-processor`) which runs on our infrastructure within a child subprocess workers abstraction and it computes (when its container starts with an empty o1js cache) via a single worker the vk hash to be `18898419980749081858185627310467310990096965437609867313373155526674043887824` before spawning a pool of workers which recompile EthVerifier themselves in parallel and derive the same vk hash. You can verify `18898419980749081858185627310467310990096965437609867313373155526674043887824` is derived by running one of these tests e.g. `rm ~/.cache/o1js/* && cd <nori-bridge-sdk root directory>/contracts/mina/eth-processor && npm run test-ci`, which also computes the same vk hash, these tests do not use the workers abstraction but 'test-ci' runs each test one after another each within it unique node.js runtime. Alternatively if one runs 'test' as opposed to 'test-ci' it will run the same test but one will experience hanging behaviour where certain o1js async prove methods never resolve / reject.

The EthProcessorRabbit private repository has an equivalent of proofSubmitter class, but has one which verifies the vk hash matches the stored hash (stored / updated by running the `npm run bake-vk-hashes`) before it allows a fleet of workers to compile (in parallel) using the common cache, such that they too come up with the same vk hash, when they finish compilation. This particular procedure was invented due to use having problems with the cache. Prior to us blocking the instantiation of the worker process pool while a single worker compiles and populates the common cache, we allowed all workers (child sub processes) to compile simulatiously using the common cache and in this case we could come up with a different vk ending in 65. We assumed this was due to some sort of contention and subsequent corruption, and put in a mitigation strategy previously describe which has led us to more consistent behaviour, this action was endorsed by o1js senior technical leadership at the time.

Recently we have while trying to get our e2e solution working (see the e2e tests here `<nori-bridge-sdk-root-dir>/contracts/mina/token-bridge` and here `<nori-bridge-sdk-root-dir>/contracts/mina/token-bridge/slim`) we have noticed that the devnet tests would only complete (in node.js, the solution is inoperable in the browser) when (with a properly configure .env file) we run the `e2e.prerequisites.spec.ts` test before hand i.e. `cd <nori-bridge-sdk root directory>/contracts/mina/token-bridge && rm ~/.cache/o1js/* && npm run test -- src/e2e.prerequisites.spec.ts && npm run test -- src/e2e.devnet.spec.ts` and the devnet tests would fail otherwise if running `cd <nori-bridge-sdk root directory>/contracts/mina/token-bridge && npm run test -- src/e2e.prerequisites.spec.ts`.

So what is the affect of running the pre-requisites test before? 

Without running the pre-requisites test before and with an empty cache EthVerifier will compile in the tests with the verification key hash ending '24'.

If we clear the cache, run the pre-requisites test it will compile EthVerifier with a verification key hash ending in '65' (the same situation as what we were experiencing with the workers). Then if the devnet test is subsequently run it will use the cache (aka the one which some compiled artifacts relating to EthVerifier made during the pre-requisites test) then when the devnet test compiles EthVerifier it too will compile and yield a verification key hash ending in '65'. 

Whats the difference between this situation and the parallel workers situation?

The pre-requisites test has no workers (no child sub processes), all of the logic runs in a single thread, the main thread! This leads me to believe that the situation is not limited to the corruption of the same cache directory by some parallel read/write access of worker sub processes but more fundamental. 

Moreover some difference between the workerfied EthProcessor solution scenario and the pre-requisites test worth mentioning; is that within our worker solution we only compute and verify EthVerfier first before compiling EthProcessor. With the pre-requisites test compiles some other ZK programs prior to compiling EthVerifier namely `EcdsaSigPresentationSpecPreCompile`, `EcdsaSigPresentationVerifier`, `EcdsaEthereum` (located in `<nori-bridge-sdk-root-dir>/contracts/mina/token-bridge/src/credentialAttestation.ts`) along with some helpers compiled within MinaAttestations (there is some HashHelper zk program).

This leads me to believe that the vk we obtain for ethVerifier when the cache is cold and when no other zk programs have been compiled prior to it, is actually different to one where some number of other zk programs have been compiled before it. That the vk hash derived from the compilation of our zk program is not always deterministic in all compilation scenarios.

# Steps to reproduce

0. `cd <nori-bridge-sdk root directory> && npm install && npm run build`
1. Run a program which compiles EthVerifier with an ephemeral cache directory (always clear)`cd <nori-bridge-sdk-root-dir>/o1js-zk-utils && npm run bake-vk-hashes`
2. Observe the printed EthVerifier Verification Key hash output `EthVerifier contract compiled vk: '18898419980749081858185627310467310990096965437609867313373155526674043887824'.`
3. Run the src/e2e.prerequisites.spec.ts test `cd <nori-bridge-sdk root directory>/contracts/mina/token-bridge && rm ~/.cache/o1js/* && npm run test -- src/e2e.prerequisites.spec.ts`