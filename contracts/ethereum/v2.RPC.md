# NoriTokenBridge v2 RPC — Change Request

## Title
NoriTokenBridge v2 — Bridge ETH to Mina with unit scaling, depositor binding, and admin withdraw

## Status
Proposed / Draft

## Author
Jonathan Kelsey

## Date
08-10-2025

## Summary
This change updates the existing `NoriTokenBridge` contract to:  

1. Scale ETH deposits to Mina-compatible bridge units (`DECIMALS = 6`).  
2. Track total locked supply and enforce a maximum (`MAX_MAGNITUDE = 2^63 - 1`).  
3. Bind each Mina account (attestationHash) to a single ETH depositor.  
4. Add an admin-only withdraw function to retrieve all ETH from the contract.  
5. Introduce structured validation and lock logic for clarity and safety.

## Motivation
The original bridge contract simply recorded ETH deposits per attestationHash without enforcing:  

- Mina-compatible scaling  
- Maximum total locked supply  
- Single-depositor constraint per Mina account  
- Admin-controlled withdrawals  

## Reference Implementation

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

/// @title NoriTokenBridge
/// @notice Lock ETH for Mina accounts with bridge unit validation and depositor binding
contract NoriTokenBridge {
    // -------------------------------
    // Constants (these should be slotless and converted to bytecode)
    // -------------------------------
    uint8 public constant DECIMALS = 6; 
    uint64 public constant MAX_MAGNITUDE = (1 << 63) - 1; // 63-bit magnitude
    uint256 public constant WEI_PER_BRIDGE_UNIT = 10 ** (18 - DECIMALS); // smallest bridge unit in wei

    // -------------------------------
    // State Variables
    // -------------------------------
    address public bridgeOperator;

    // ETH locked per ETH address per Mina account (attestationHash)
    mapping(address => mapping(uint256 => uint256)) public lockedTokens;

    // Total locked supply in bridge units
    uint256 public totalLocked;

    // Mina account (attestationHash) -> ETH depositor
    mapping(uint256 => address) public codeChallengeToEthAddress;

    // -------------------------------
    // Events
    // -------------------------------
    event TokensLocked(address indexed user, uint256 attestationHash, uint256 amount, uint256 totalLocked, uint256 when);

    // -------------------------------
    // Constructor
    // -------------------------------
    constructor() {
        bridgeOperator = msg.sender;
    }

    // -------------------------------
    // Lock ETH for a Mina account
    // -------------------------------
    function lockTokens(uint256 attestationHash) public payable {
        // ===============================
        // VALIDATION
        // ===============================
        require(msg.value > 0, "You must send some Ether to lock");

        // Convert wei to bridge units
        uint256 bridgeAmount = msg.value / WEI_PER_BRIDGE_UNIT;

        // Ensure deposit is a whole multiple of bridge unit
        require(msg.value % WEI_PER_BRIDGE_UNIT == 0, "Must be multiple of smallest bridge unit");

        // Ensure total locked supply does not exceed MAX_MAGNITUDE
        require(totalLocked + bridgeAmount <= MAX_MAGNITUDE, "Total locked exceeds maximum allowed");

        // Enforce one ETH depositor per Mina account
        address linkedEth = codeChallengeToEthAddress[attestationHash];
        if (linkedEth == address(0)) {
            // First deposit: bind Mina account to sender
            codeChallengeToEthAddress[attestationHash] = msg.sender;
        } else {
            require(linkedEth == msg.sender, "This Mina account is already linked to a different ETH address");
        }

        // ===============================
        // LOCK LOGIC
        // ===============================
        lockedTokens[msg.sender][attestationHash] += msg.value;
        totalLocked += bridgeAmount;

        emit TokensLocked(msg.sender, attestationHash, msg.value, totalLocked, block.timestamp);
    }

    // -------------------------------
    // Admin-only withdraw all ETH
    // -------------------------------
    function withdraw() public {
        require(msg.sender == bridgeOperator, "Only bridge operator can withdraw");

        uint256 balance = address(this).balance;
        require(balance > 0, "No ETH to withdraw");

        payable(bridgeOperator).transfer(balance);
    }
}
```

## Changes in the Updated Bridge

1. **Bridge unit scaling for Mina compatibility**  
   - Introduced `DECIMALS = 6` to define the smallest bridge unit (0.000001 ETH).  
   - Added `WEI_PER_BRIDGE_UNIT = 10 ** (18 - DECIMALS)` to convert ETH (wei) to bridge units compatible with Mina's 64-bit magnitude.  
   - Deposits must be multiples of the smallest bridge unit.  

2. **Maximum magnitude enforcement**  
   - Added `MAX_MAGNITUDE = 2^63 - 1` to ensure total locked supply never exceeds Mina’s 63-bit signed capacity.  
   - `totalLocked` variable tracks the sum of all deposits in bridge units.  
   - Each new deposit checks `totalLocked + bridgeAmount <= MAX_MAGNITUDE`.  

3. **Mina account depositor binding**  
   - Added `codeChallengeToEthAddress` mapping.  
   - Each Mina account (attestationHash) can only be linked to **one ETH depositor**.  
   - Multiple ETH addresses can deposit to different Mina accounts.  
   - First deposit sets the binding; subsequent deposits require `msg.sender` to match the bound address.  

4. **Validation and lock logic sections**  
   - Structured comments: `// =============================== VALIDATION ===============================` and `// =============================== LOCK LOGIC ===============================`.  
   - Validation checks include: `msg.value > 0`, multiples of bridge unit, total locked limit, and depositor binding.  
   - Lock logic updates `lockedTokens` and `totalLocked`, and emits `TokensLocked` event including updated `totalLocked`.  

5. **Admin withdraw function**  
   - Added `withdraw()` restricted to `bridgeOperator` to withdraw all ETH from the contract.  
   - Silent — no event emitted.  
   - Does **not modify** `lockedTokens` or `totalLocked`, so bridge accounting remains intact.  

6. **Overall structure improvements**  
   - Constants, state variables, events, validation, lock logic, and admin withdraw are clearly separated.  
   - The contract now safely scales ETH deposits to Mina units, enforces depositor rules, and ensures bridge safety limits.

## Justification

- **Mina account representation**  
  Mina accounts use `uint64` with a separate sign bit, effectively a **65-bit signed integer**. On Ethereum, we use `uint256`, which allows for extremely large values (~1.16 × 10^77), so there is ample headroom for deposits.

- **Magnitude vs decimals calculation**  
  To safely scale ETH deposits to Mina units:

  1. Max raw unsigned integer value:

  ```
  I_max = 2^b - 1
  ```

  where `b = 64` (bits for magnitude).

  2. Maximum bridge value accounting for decimals:

  ```
  V_max = I_max / (10^d)
  ```

  where `d = decimals` chosen for the bridge unit.

- **Example calculations**

  - If we used 18 decimals (ETH standard):

  ```
  V_max = (2^64 - 1) / 10^18 ≈ 18.46
  ```

  - With our selected `DECIMALS = 6`:

  ```
  V_max = (2^64 - 1) / 10^6 ≈ 1.8446744 × 10^13
  ```

- **Bridge base unit**

  ```
  base unit = 10^-DECIMALS = 0.000001 ETH
  ```

  This ensures that deposits are always multiples of the smallest bridge unit, allowing safe conversion to Mina's 64-bit magnitude without fractional rounding.

- **Summary**

  - ETH deposits are scaled down to Mina-compatible units using `DECIMALS = 6`.  
  - Maximum deposit is capped by `MAX_MAGNITUDE = 2^63 - 1` in bridge units.  
  - Smallest deposit unit is `0.000001 ETH`, ensuring integer bridge units and preventing precision loss.